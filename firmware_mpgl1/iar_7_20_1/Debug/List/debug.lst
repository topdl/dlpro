###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        15/Jun/2016  16:14:16
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpg_common\application\debug.c
#    Command line =  
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpg_common\application\debug.c -D
#        MPGL1 -D MPG1 --preprocess=cl
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\Debug\List\ -lC
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\Debug\List\ -o
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config F:\elenic\arm\INC\c\DLib_Config_Normal.h -I
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\ -I
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\..\bsp\ -I
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\..\drivers\ -I
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\..\application\ -I
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline -I F:\elenic\arm\CMSIS\Include\
#    List file    =  
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\Debug\List\debug.lst
#    Object file  =  
#        F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpgl1\iar_7_20_1\Debug\Obj\debug.o
#
###############################################################################

F:\ѧϰ\EiE\eiegit\dlpro\firmware_mpg_common\application\debug.c
      1          /***********************************************************************************************************************
                                                                                                                                        ^
Warning[Pa050]: non-native end of line sequence detected (this diagnostic is
          only issued once)
      2          File: debug.c                                                                
      3          
      4          Description:
      5          Debugging functions and state machine.  Since the system is small, debugger commands
      6          will be strictly numerical, though each command will have a string name that can
      7          be requested by the user.  The debugger will print a list of these commands if 
      8          requested using en+c00.  Commands range from 01 to 99 (must include the leading 0
      9          for single-digit commands) and all commands must have the prefix en+c. 
     10          The current command list can be quickly checked in debug_x.h (where x is application-specific)
     11          
     12          This application requires a UART resource for input/output data.
     13          
     14          The terminal program used to interface to the debugger should be set to:
     15          - no local echo
     16          - send "CR" for new line
     17          - 115200-8-N-1
     18          
     19          
     20          ------------------------------------------------------------------------------------------------------------------------
     21          API:
     22          Types: none
     23          
     24          Globals:
     25          G_au8DebugScanfBuffer[] is the DebugScanf() input buffer that can be read directly
     26          G_u8DebugScanfCharCount holds number of characters in Debug_au8ScanfBuffer
     27          Both of these variables are cleared whenever DebugScanf() is called.
     28          
     29          Constants:
     30          DEBUG_SCANF_BUFFER_SIZE is the size of G_au8DebugScanfBuffer and thus the max of G_u8DebugScanfCharCount
     31          
     32          Public:
     33          u32 DebugPrintf(u8* u8String_)
     34          Queues the string pointed to by u8String_ to the Debug port.  The string must be
     35          null-terminated.  It may also contain control charactesr like newline (\n) and line feed (\f)
     36          e.g.
     37          u8 u8String[] = "A string to print.\n\r"
     38          DebugPrintf(u8String);
     39          
     40          void DebugLineFeed(void)
     41          Queues a <CR><LF> sequence to the debug UART.
     42          e.g.
     43          DebugLineFeed();
     44          
     45          void DebugPrintNumber(u32 u32Number_)
     46          Formats a long into an ASCII string and queues to print.  Leading zeros are not printed.
     47          e.g.
     48          u32 u32Number = 1234567;
     49          DebugPrintNumber(u32Number);
     50          
     51          u8 DebugScanf(u8* au8Buffer_)
     52          Copies the current input buffer to au8Buffer_ and returns the number of new characters.
     53          Everytime DebugScanf is called, the 
     54          e.g.
     55          u8 u8MyBuffer[SCANF_BUFFER_SIZE]
     56          u8 u8NumChars;
     57          u8NumChars = DebugScanf(u8MyBuffer);
     58          
     59          
     60          DISCLAIMER: THIS CODE IS PROVIDED WITHOUT ANY WARRANTY OR GUARANTEES.  USERS MAY
     61          USE THIS CODE FOR DEVELOPMENT AND EXAMPLE PURPOSES ONLY.  ENGENUICS TECHNOLOGIES
     62          INCORPORATED IS NOT RESPONSIBLE FOR ANY ERRORS, OMISSIONS, OR DAMAGES THAT COULD
     63          RESULT FROM USING THIS FIRMWARE IN WHOLE OR IN PART.
     64          
     65          ***********************************************************************************************************************/
     66          
     67          #include "configuration.h"
     68          
     69          /***********************************************************************************************************************
     70          Global variable definitions with scope across entire project.
     71          All Global variable names shall start with "G_Debug"
     72          ***********************************************************************************************************************/
     73          /* New variables */

   \                                 In section .bss, align 4
     74          u32 G_u32DebugFlags;                                     /* Debug flag register */
   \                     G_u32DebugFlags:
   \   00000000                      DS8 4
     75          

   \                                 In section .bss, align 4
     76          u8 G_au8DebugScanfBuffer[DEBUG_SCANF_BUFFER_SIZE]; /* Space to latch characters for DebugScanf() */
   \                     G_au8DebugScanfBuffer:
   \   00000000                      DS8 128

   \                                 In section .bss, align 1
     77          u8 G_u8DebugScanfCharCount = 0;                    /* Counter for # of characters in Debug_au8ScanfBuffer */
   \                     G_u8DebugScanfCharCount:
   \   00000000                      DS8 1
     78          
     79          
     80          /*--------------------------------------------------------------------------------------------------------------------*/
     81          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     82          extern volatile u32 G_u32SystemFlags;                    /* From main.c */
     83          extern volatile u32 G_u32ApplicationFlags;               /* From main.c */
     84          
     85          extern volatile u32 G_u32SystemTime1ms;                  /* From board-specific source file */
     86          extern volatile u32 G_u32SystemTime1s;                   /* From board-specific source file */
     87          
     88          extern u8 G_au8MessageOK[];                              /* From utilities.c */
     89          extern u8 G_au8MessageFAIL[];                            /* From utilities.c */
     90          extern u8 G_au8MessageON[];                              /* From utilities.c */
     91          extern u8 G_au8MessageOFF[];                             /* From utilities.c */
     92          
     93          
     94          /***********************************************************************************************************************
     95          Global variable definitions with scope limited to this local application.
     96          Variable names shall start with "Debug_" and be declared as static.
     97          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     98          static fnCode_type Debug_pfnStateMachine;                /* The Debug state machine function pointer */
   \                     Debug_pfnStateMachine:
   \   00000000                      DS8 4
     99          

   \                                 In section .bss, align 4
    100          static UartPeripheralType* Debug_Uart;                   /* Pointer to debug UART peripheral object */
   \                     Debug_Uart:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    101          static u32 Debug_u32CurrentMessageToken;                 /* Token for current message */
   \                     Debug_u32CurrentMessageToken:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    102          static u8 Debug_u8ErrorCode;                             /* Error code */
   \                     Debug_u8ErrorCode:
   \   00000000                      DS8 1
    103          

   \                                 In section .bss, align 4
    104          static u8 Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE];       /* Space for incoming characters of debug commands */
   \                     Debug_au8RxBuffer:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
    105          static u8 *Debug_pu8RxBufferNextChar;                    /* Pointer to next spot in the Rxbuffer */
   \                     Debug_pu8RxBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    106          static u8 *Debug_pu8RxBufferParser;                      /* Pointer to loop through the Rx buffer */
   \                     Debug_pu8RxBufferParser:
   \   00000000                      DS8 4
    107          

   \                                 In section .bss, align 4
    108          static u8 Debug_au8CommandBuffer[DEBUG_CMD_BUFFER_SIZE]; /* Space to store chars as they build up to the next command */ 
   \                     Debug_au8CommandBuffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
    109          static u8 *Debug_pu8CmdBufferNextChar;                   /* Pointer to incoming char location in the command buffer */
   \                     Debug_pu8CmdBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
    110          static u16 Debug_u16CommandSize;                         /* Number of characters in the command buffer */
   \                     Debug_u16CommandSize:
   \   00000000                      DS8 2
    111          

   \                                 In section .bss, align 1
    112          static u8 Debug_u8Command;                               /* A validated command number */
   \                     Debug_u8Command:
   \   00000000                      DS8 1
    113          
    114          /* Add commands by updating debug.h in the Command-Specific Definitions section, then update this list
    115          with the function name to call for the corresponding command: */
    116          #ifdef MPGL1

   \                                 In section .data, align 4
    117          DebugCommandType Debug_au8Commands[DEBUG_COMMANDS] = { {DEBUG_CMD_NAME00, DebugCommandPrepareList},
   \                     Debug_au8Commands:
   \   00000000   0x........         DC32 ?_0, DebugCommandPrepareList, ?_1, DebugCommandLedTestToggle, ?_2
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000014   0x........         DC32 DebugCommandSysTimeToggle, ?_3, DebugCommandDummy, ?_4
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000024   0x........         DC32 DebugCommandDummy, ?_5, DebugCommandDummy, ?_6, DebugCommandDummy
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000038   0x........         DC32 ?_7, DebugCommandDummy
   \              0x........   
    118                                                                 {DEBUG_CMD_NAME01, DebugCommandLedTestToggle},
    119                                                                 {DEBUG_CMD_NAME02, DebugCommandSysTimeToggle},
    120                                                                 {DEBUG_CMD_NAME03, DebugCommandDummy},
    121                                                                 {DEBUG_CMD_NAME04, DebugCommandDummy},
    122                                                                 {DEBUG_CMD_NAME05, DebugCommandDummy},
    123                                                                 {DEBUG_CMD_NAME06, DebugCommandDummy},
    124                                                                 {DEBUG_CMD_NAME07, DebugCommandDummy} 
    125                                                               };
    126          

   \                                 In section .data, align 4
    127          static u8 Debug_au8StartupMsg[] = "\n\n\r*** RAZOR SAM3U2 ASCII LCD DEVELOPMENT BOARD ***\n\rDebug ready\n\r";
   \                     Debug_au8StartupMsg:
   \   00000000   0x0A 0x0A          DC8 0AH, 0AH, 0DH, 2AH, 2AH, 2AH, 20H, 52H
   \              0x0D 0x2A    
   \              0x2A 0x2A    
   \              0x20 0x52    
   \   00000008   0x41 0x5A          DC8 41H, 5AH, 4FH, 52H, 20H, 53H, 41H, 4DH
   \              0x4F 0x52    
   \              0x20 0x53    
   \              0x41 0x4D    
   \   00000010   0x33 0x55          DC8 33H, 55H, 32H, 20H, 41H, 53H, 43H, 49H
   \              0x32 0x20    
   \              0x41 0x53    
   \              0x43 0x49    
   \   00000018   0x49 0x20          DC8 49H, 20H, 4CH, 43H, 44H, 20H, 44H, 45H
   \              0x4C 0x43    
   \              0x44 0x20    
   \              0x44 0x45    
   \   00000020   0x56 0x45          DC8 56H, 45H, 4CH, 4FH, 50H, 4DH, 45H, 4EH
   \              0x4C 0x4F    
   \              0x50 0x4D    
   \              0x45 0x4E    
   \   00000028   0x54 0x20          DC8 54H, 20H, 42H, 4FH, 41H, 52H, 44H, 20H
   \              0x42 0x4F    
   \              0x41 0x52    
   \              0x44 0x20    
   \   00000030   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 0AH, 0DH, 44H, 65H, 62H
   \              0x2A 0x0A    
   \              0x0D 0x44    
   \              0x65 0x62    
   \   00000038   0x75 0x67          DC8 75H, 67H, 20H, 72H, 65H, 61H, 64H, 79H
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \   00000040   0x0A 0x0D          DC8 0AH, 0DH, 0
   \              0x00         
   \   00000043   0x00               DC8 0
    128          #endif /* MPGL1 */
    129          
    130          #ifdef MPGL2
    131          DebugCommandType Debug_au8Commands[DEBUG_COMMANDS] = { {DEBUG_CMD_NAME00, DebugCommandPrepareList},
    132                                                                 {DEBUG_CMD_NAME01, DebugCommandLedTestToggle},
    133                                                                 {DEBUG_CMD_NAME02, DebugCommandSysTimeToggle},
    134                                                                 {DEBUG_CMD_NAME03, DebugCommandCaptouchValuesToggle},
    135                                                                 {DEBUG_CMD_NAME04, DebugCommandDummy},
    136                                                                 {DEBUG_CMD_NAME05, DebugCommandDummy},
    137                                                                 {DEBUG_CMD_NAME06, DebugCommandDummy},
    138                                                                 {DEBUG_CMD_NAME07, DebugCommandDummy} 
    139                                                               };
    140          
    141          static u8 Debug_au8StartupMsg[] = "\n\n\r*** RAZOR SAM3U2 DOT MATRIX DEVELOPMENT BOARD ***\n\rDebug ready\n\r";
    142          #endif /* MPGL2 */
    143          
    144          
    145          /***********************************************************************************************************************
    146          * Function Definitions
    147          ***********************************************************************************************************************/
    148          
    149          /*--------------------------------------------------------------------------------------------------------------------*/
    150          /* Public Functions */
    151          /*--------------------------------------------------------------------------------------------------------------------*/
    152          
    153          /*----------------------------------------------------------------------------------------------------------------------
    154          Function: DebugPrintf
    155          
    156          Description:
    157          Sends a text string to the debug UART.
    158          
    159          Requires:
    160            - u8String_ is a NULL-terminated C-string
    161            - The debug UART resource has been setup for the debug application.
    162          
    163          Promises:
    164            - The string is queued to the debug UART.
    165            - The message token is returned
    166          */

   \                                 In section .text, align 2, keep-with-next
    167          u32 DebugPrintf(u8* u8String_)
    168          {
   \                     DebugPrintf: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    169            u8* pu8Parser = u8String_;
   \   00000004   0x0025             MOVS     R5,R4
    170            u32 u32Size = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    171            
    172            while(*pu8Parser != NULL)
   \                     ??DebugPrintf_0: (+1)
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD002             BEQ.N    ??DebugPrintf_1
    173            {
    174              u32Size++;
   \   0000000E   0x1C76             ADDS     R6,R6,#+1
    175              pu8Parser++;
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
   \   00000012   0xE7F9             B.N      ??DebugPrintf_0
    176            }
    177            return( UartWriteData(Debug_Uart, u32Size, u8String_) );
   \                     ??DebugPrintf_1: (+1)
   \   00000014   0x0022             MOVS     R2,R4
   \   00000016   0x0031             MOVS     R1,R6
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      BL       UartWriteData
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    178           
    179          } /* end DebugPrintf() */
    180          
    181          
    182          /*----------------------------------------------------------------------------------------------------------------------
    183          Function: DebugLineFeed
    184          
    185          Description:
    186          Queues a <CR><LF> sequence to the debug UART.
    187          
    188          Requires:
    189            -
    190          
    191          Promises:
    192            - <CR><LF> sequence to the debug UART
    193          */

   \                                 In section .text, align 2, keep-with-next
    194          void DebugLineFeed(void)
    195          {
   \                     DebugLineFeed: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    196            u8 au8Linefeed[] = {ASCII_LINEFEED, ASCII_CARRIAGE_RETURN};
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_1
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    197            
    198            UartWriteData(Debug_Uart, sizeof(au8Linefeed), &au8Linefeed[0]);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       UartWriteData
    199          
    200          } /* end DebugLineFeed() */
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    201          
    202          
    203          /*-----------------------------------------------------------------------------/
    204          Function: DebugPrintNumber
    205          
    206          Description:
    207          Formats a long into an ASCII string and queues to print
    208          
    209          Requires:
    210            - Enough space is available on the heap to temporarily store the number array
    211          
    212          Promises:
    213            - The number is converted to an array of ascii without leading zeros and sent to UART
    214          */

   \                                 In section .text, align 2, keep-with-next
    215          void DebugPrintNumber(u32 u32Number_)
    216          {
   \                     DebugPrintNumber: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    217            bool bFoundDigit = FALSE;
   \   00000006   0x2500             MOVS     R5,#+0
    218            u8 au8AsciiNumber[10];
    219            u8 u8CharCount = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    220            u32 u32Temp, u32Divider = 1000000000;
   \   0000000A   0x.... 0x....      LDR.W    R8,??DataTable15_2  ;; 0x3b9aca00
    221            u8 *pu8Data;
    222          
    223            /* Parse out all the digits, start counting after leading zeros */
    224            for(u8 index = 0; index < 10; index++)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??DebugPrintNumber_0: (+1)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x280A             CMP      R0,#+10
   \   00000014   0xDA19             BGE.N    ??DebugPrintNumber_1
    225            {
    226              au8AsciiNumber[index] = (u32Number_ / u32Divider) + 0x30;
   \   00000016   0xFBB4 0xF1F8      UDIV     R1,R4,R8
   \   0000001A   0x3130             ADDS     R1,R1,#+48
   \   0000001C   0xAA00             ADD      R2,SP,#+0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x5481             STRB     R1,[R0, R2]
    227              if(au8AsciiNumber[index] != '0')
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x5C41             LDRB     R1,[R0, R1]
   \   00000028   0x2930             CMP      R1,#+48
   \   0000002A   0xD001             BEQ.N    ??DebugPrintNumber_2
    228              {
    229                bFoundDigit = TRUE;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x000D             MOVS     R5,R1
    230              }
    231              if(bFoundDigit)
   \                     ??DebugPrintNumber_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD000             BEQ.N    ??DebugPrintNumber_3
    232              {
    233                u8CharCount++;
   \   00000036   0x1C76             ADDS     R6,R6,#+1
    234              }
    235              u32Number_ %= u32Divider;
   \                     ??DebugPrintNumber_3: (+1)
   \   00000038   0xFBB4 0xF1F8      UDIV     R1,R4,R8
   \   0000003C   0xFB08 0x4411      MLS      R4,R8,R1,R4
    236              u32Divider /= 10;
   \   00000040   0x210A             MOVS     R1,#+10
   \   00000042   0xFBB8 0xF8F1      UDIV     R8,R8,R1
    237            }
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xE7E2             B.N      ??DebugPrintNumber_0
    238            
    239            /* Handle special case where u32Number == 0 */
    240            if(!bFoundDigit)
   \                     ??DebugPrintNumber_1: (+1)
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD101             BNE.N    ??DebugPrintNumber_4
    241            {
    242              u8CharCount = 1;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x0006             MOVS     R6,R0
    243            }
    244            
    245            /* Allocate memory for the right number and copy the array */
    246            pu8Data = malloc(u8CharCount);
   \                     ??DebugPrintNumber_4: (+1)
   \   00000054   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000056   0x0030             MOVS     R0,R6
   \   00000058   0x.... 0x....      BL       malloc
   \   0000005C   0x4681             MOV      R9,R0
    247            if (pu8Data == NULL)
   \   0000005E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000062   0xD108             BNE.N    ??DebugPrintNumber_5
    248            {
    249              Debug_u8ErrorCode = DEBUG_ERROR_MALLOC;
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
    250              Debug_pfnStateMachine = DebugSM_Error;
   \   0000006C   0x.... 0x....      ADR.W    R0,DebugSM_Error
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000074   0x6008             STR      R0,[R1, #+0]
    251            }
    252            
    253            u32Temp = 9;
   \                     ??DebugPrintNumber_5: (+1)
   \   00000076   0x2009             MOVS     R0,#+9
   \   00000078   0x0007             MOVS     R7,R0
    254            for(u8 index = u8CharCount; index != 0; index--)
   \   0000007A   0x0030             MOVS     R0,R6
   \                     ??DebugPrintNumber_6: (+1)
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD009             BEQ.N    ??DebugPrintNumber_7
    255            {
    256              pu8Data[index - 1] = au8AsciiNumber[u32Temp--];
   \   00000082   0xA900             ADD      R1,SP,#+0
   \   00000084   0x5C79             LDRB     R1,[R7, R1]
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0xEB10 0x0209      ADDS     R2,R0,R9
   \   0000008C   0xF802 0x1C01      STRB     R1,[R2, #-1]
   \   00000090   0x1E7F             SUBS     R7,R7,#+1
    257            }
   \   00000092   0x1E40             SUBS     R0,R0,#+1
   \   00000094   0xE7F2             B.N      ??DebugPrintNumber_6
    258              
    259            /* Print the ascii string and free the memory */
    260            UartWriteData(Debug_Uart, u8CharCount, pu8Data);
   \                     ??DebugPrintNumber_7: (+1)
   \   00000096   0x464A             MOV      R2,R9
   \   00000098   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   0x0031             MOVS     R1,R6
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable15
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x.... 0x....      BL       UartWriteData
    261            free(pu8Data);
   \   000000A6   0x4648             MOV      R0,R9
   \   000000A8   0x.... 0x....      BL       free
    262            
    263          } /* end DebugDebugPrintNumber() */
   \   000000AC   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    264          
    265          
    266          /*----------------------------------------------------------------------------------------------------------------------
    267          Function: DebugScanf
    268          
    269          Description:
    270          Copies G_u8DebugScanfCharCount characters from G_au8DebugScanfBuffer to a target array 
    271          so the input can be saved.  Once copied, G_au8DebugScanfBuffer is cleared and
    272          G_u8DebugScanfCharCount is zeroed.
    273          
    274          Requires:
    275            - G_u8DebugScanfCharCount holds the number of characters in the G_au8DebugScanfBuffer
    276            - au8Buffer_ points to an array large enough to hold G_u8DebugScanfCharCount characters
    277            - Debug task is blocked here so new characters are not added
    278          
    279          Promises:
    280            - G_u8DebugScanfCharCount characters copied to *au8Buffer_
    281            - G_au8DebugScanfBuffer[i] = '\0', where 0 <= i <= DEBUG_SCANF_BUFFER_SIZE
    282            - G_u8DebugScanfCharCount = 0
    283          */

   \                                 In section .text, align 2, keep-with-next
    284          u8 DebugScanf(u8* au8Buffer_)
    285          {
   \                     DebugScanf: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    286            u8 u8Temp = G_u8DebugScanfCharCount;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
    287            
    288            /* Copy the characters, clearing as we go */
    289            for(u8 i = 0; i < G_u8DebugScanfCharCount; i++)
   \   0000000A   0x2200             MOVS     R2,#+0
   \                     ??DebugScanf_0: (+1)
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable15_5
   \   00000010   0x781B             LDRB     R3,[R3, #+0]
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0x429A             CMP      R2,R3
   \   00000016   0xD20C             BCS.N    ??DebugScanf_1
    290            {
    291              *(au8Buffer_ + i) = G_au8DebugScanfBuffer[i];
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable15_6
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0x5CD3             LDRB     R3,[R2, R3]
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x5453             STRB     R3,[R2, R1]
    292              G_au8DebugScanfBuffer[i] = '\0';
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x.... 0x....      LDR.W    R4,??DataTable15_6
   \   0000002A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   0x5513             STRB     R3,[R2, R4]
    293            }
   \   0000002E   0x1C52             ADDS     R2,R2,#+1
   \   00000030   0xE7EC             B.N      ??DebugScanf_0
    294            
    295            G_u8DebugScanfCharCount = 0;
   \                     ??DebugScanf_1: (+1)
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x.... 0x....      LDR.W    R3,??DataTable15_5
   \   00000038   0x701A             STRB     R2,[R3, #+0]
    296            return u8Temp;
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBC10             POP      {R4}
   \   0000003E   0x4770             BX       LR               ;; return
    297            
    298          } /* end DebugScanf() */
    299          
    300          
    301          /*----------------------------------------------------------------------------------------------------------------------
    302          Function: SystemStatusReport
    303          
    304          Description:
    305          Reports if system is good or not.
    306          
    307          Requires:
    308            - G_u32SystemFlags up to date with system status
    309            - New tasks should be added to the check list below including in the message string for the task name
    310            - The system is in initialization state so MsgSenderForceSend() is used
    311              to output each meassage after it is queued.
    312          
    313          Promises:
    314            - Prints out messages for any system tests that failed
    315            - Prints out overall good message if all tests passed
    316          */

   \                                 In section .text, align 2, keep-with-next
    317          void SystemStatusReport(void)
    318          {
   \                     SystemStatusReport: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0A4             SUB      SP,SP,#+144
    319          
    320            u8 au8SystemPassed[] = "NONE";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_7
   \   0000000A   0x2205             MOVS     R2,#+5
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    321            u8 au8SystemReady[] = "\n\rInitialization complete. Type en+c00 for debug menu.  Failed tasks:\n\r";
   \   00000010   0xA811             ADD      R0,SP,#+68
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable15_8
   \   00000016   0x2248             MOVS     R2,#+72
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy4
    322            u32 u32TaskFlagMaskBit = (u32)0x01;
   \   0000001C   0x2401             MOVS     R4,#+1
    323            bool bNoFailedTasks = TRUE;
   \   0000001E   0x2501             MOVS     R5,#+1
    324          
    325          #ifdef MPGL1
    326            u8 aau8AppShortNames[NUMBER_APPLICATIONS][MAX_TASK_NAME_SIZE] = {"LED", "BUTTON", "DEBUG", "LCD", "ANT", "SD"};
   \   00000020   0xA802             ADD      R0,SP,#+8
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable15_9
   \   00000026   0x223C             MOVS     R2,#+60
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy4
    327          #endif /* MPGL1 */
    328          
    329          #ifdef MPGL2
    330            u8 aau8AppShortNames[NUMBER_APPLICATIONS][MAX_TASK_NAME_SIZE] = {"LED", "BUTTON", "DEBUG", "LCD", "ANT", "CAPTOUCH"};
    331          #endif /* MPGL2 */
    332          
    333            /* Announce init complete then report any tasks that failed init */
    334            DebugPrintf(au8SystemReady);
   \   0000002C   0xA811             ADD      R0,SP,#+68
   \   0000002E   0x.... 0x....      BL       DebugPrintf
    335              
    336            for(u8 i = 0; i < NUMBER_APPLICATIONS; i++)
   \   00000032   0x2600             MOVS     R6,#+0
   \                     ??SystemStatusReport_0: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E06             CMP      R6,#+6
   \   00000038   0xDA12             BGE.N    ??SystemStatusReport_1
    337            {
    338              if( !(u32TaskFlagMaskBit & G_u32ApplicationFlags) )
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable15_10
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4204             TST      R4,R0
   \   00000042   0xD10A             BNE.N    ??SystemStatusReport_2
    339              {
    340                bNoFailedTasks = FALSE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0005             MOVS     R5,R0
    341                DebugPrintf(&aau8AppShortNames[i][0]);
   \   00000048   0xA802             ADD      R0,SP,#+8
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x210A             MOVS     R1,#+10
   \   0000004E   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000052   0x.... 0x....      BL       DebugPrintf
    342                DebugLineFeed();
   \   00000056   0x.... 0x....      BL       DebugLineFeed
    343              }
    344              
    345              u32TaskFlagMaskBit <<= 1;
   \                     ??SystemStatusReport_2: (+1)
   \   0000005A   0x0064             LSLS     R4,R4,#+1
    346            }     
   \   0000005C   0x1C76             ADDS     R6,R6,#+1
   \   0000005E   0xE7E9             B.N      ??SystemStatusReport_0
    347                  
    348            if( bNoFailedTasks)
   \                     ??SystemStatusReport_1: (+1)
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D00             CMP      R5,#+0
   \   00000064   0xD002             BEQ.N    ??SystemStatusReport_3
    349            {
    350              DebugPrintf(au8SystemPassed);
   \   00000066   0xA800             ADD      R0,SP,#+0
   \   00000068   0x.... 0x....      BL       DebugPrintf
    351            }
    352            
    353            DebugLineFeed();
   \                     ??SystemStatusReport_3: (+1)
   \   0000006C   0x.... 0x....      BL       DebugLineFeed
    354            
    355          } /* end SystemStatusReport() */
   \   00000070   0xB024             ADD      SP,SP,#+144
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
    356          
    357          
    358          /*--------------------------------------------------------------------------------------------------------------------*/
    359          /* Protected Functions */
    360          /*--------------------------------------------------------------------------------------------------------------------*/
    361          
    362          /*----------------------------------------------------------------------------------------------------------------------
    363          Function: DebugInitialize
    364          
    365          Description:
    366          Sets up the debug command list and activates the debug functionality.
    367          
    368          Requires:
    369            - The debug application is not yet running
    370            - The UART resource requested should be free
    371          
    372          Promises:
    373            - UART resource Debug_au8RxBuffer initialized to all 0
    374            - Buffer pointers Debug_pu8CmdBufferCurrentChar and Debug_pu8RxBufferParser set to the start of the buffer
    375            - Debug_pfnStateMachine set to Idle
    376          */

   \                                 In section .text, align 2, keep-with-next
    377          void DebugInitialize(void)
    378          {
   \                     DebugInitialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    379            UartConfigurationType sUartConfig;  
    380          
    381            /* Clear the receive buffer */
    382            for (u16 i = 0; i < DEBUG_RX_BUFFER_SIZE; i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \                     ??DebugInitialize_0: (+1)
   \   00000006   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   0x2880             CMP      R0,#+128
   \   0000000A   0xD206             BCS.N    ??DebugInitialize_1
    383            {
    384              Debug_au8RxBuffer[i] = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable15_11
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x5481             STRB     R1,[R0, R2]
    385            }
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0xE7F5             B.N      ??DebugInitialize_0
    386          
    387            /* Clear the scanf buffer and counter */
    388            G_u8DebugScanfCharCount = 0;
   \                     ??DebugInitialize_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable15_5
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    389            for (u8 i = 0; i < DEBUG_SCANF_BUFFER_SIZE; i++)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??DebugInitialize_2: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2880             CMP      R0,#+128
   \   00000028   0xDA06             BGE.N    ??DebugInitialize_3
    390            {
    391              G_au8DebugScanfBuffer[i] = 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable15_6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x5481             STRB     R1,[R0, R2]
    392            }
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0xE7F5             B.N      ??DebugInitialize_2
    393          
    394            /* Initailze startup values and the command array */
    395            Debug_pu8RxBufferParser    = &Debug_au8RxBuffer[0];
   \                     ??DebugInitialize_3: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   00000040   0x6008             STR      R0,[R1, #+0]
    396            Debug_pu8RxBufferNextChar  = &Debug_au8RxBuffer[0]; 
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable15_13
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    397            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0]; 
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable15_14
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable15_15
   \   00000054   0x6008             STR      R0,[R1, #+0]
    398          
    399            /* Request the UART resource to be used for the Debug application */
    400            sUartConfig.UartPeripheral     = DEBUG_UART;
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0xF88D 0x0000      STRB     R0,[SP, #+0]
    401            sUartConfig.pu8RxBufferAddress = &Debug_au8RxBuffer[0];
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \   00000060   0x9001             STR      R0,[SP, #+4]
    402            sUartConfig.pu8RxNextByte      = &Debug_pu8RxBufferNextChar;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \   00000066   0x9002             STR      R0,[SP, #+8]
    403            sUartConfig.u16RxBufferSize    = DEBUG_RX_BUFFER_SIZE;
   \   00000068   0x2080             MOVS     R0,#+128
   \   0000006A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    404            sUartConfig.fnRxCallback       = DebugRxCallback;
   \   0000006E   0x.... 0x....      ADR.W    R0,DebugRxCallback
   \   00000072   0x9003             STR      R0,[SP, #+12]
    405            
    406            Debug_Uart = UartRequest(&sUartConfig);
   \   00000074   0xA800             ADD      R0,SP,#+0
   \   00000076   0x.... 0x....      BL       UartRequest
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable15
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    407            
    408            /* Go to error state if the UartRequest failed */
    409            if(Debug_Uart == NULL)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable15
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD105             BNE.N    ??DebugInitialize_4
    410            {
    411              Debug_pfnStateMachine = DebugSM_Error;
   \   0000008A   0x.... 0x....      ADR.W    R0,DebugSM_Error
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000092   0x6008             STR      R0,[R1, #+0]
   \   00000094   0xE010             B.N      ??DebugInitialize_5
    412          
    413            }
    414            /* Otherwise send the first message, set "good" flag and head to Idle */
    415            else
    416            {
    417              DebugPrintf(Debug_au8StartupMsg);   
   \                     ??DebugInitialize_4: (+1)
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable15_16
   \   0000009A   0x.... 0x....      BL       DebugPrintf
    418              G_u32ApplicationFlags |= _APPLICATION_FLAGS_DEBUG;
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable15_10
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable15_10
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    419              Debug_pfnStateMachine = DebugSM_Idle;
   \   000000AE   0x.... 0x....      ADR.W    R0,DebugSM_Idle
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   000000B6   0x6008             STR      R0,[R1, #+0]
    420            }
    421            
    422          } /* end  DebugInitialize() */
   \                     ??DebugInitialize_5: (+1)
   \   000000B8   0xB005             ADD      SP,SP,#+20
   \   000000BA   0xBD00             POP      {PC}             ;; return
    423          
    424          
    425          /*----------------------------------------------------------------------------------------------------------------------
    426          Function DebugRunActiveState()
    427          
    428          Description:
    429          Selects and runs one iteration of the current state in the state machine.
    430          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    431          may take 1ms / n to execute.
    432          
    433          Requires:
    434            - State machine function pointer points at current state
    435          
    436          Promises:
    437            - Calls the function to pointed by the state machine function pointer
    438          */

   \                                 In section .text, align 2, keep-with-next
    439          void DebugRunActiveState(void)
    440          {
   \                     DebugRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    441            Debug_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    442          
    443          } /* end DebugRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    444          
    445          
    446          /*----------------------------------------------------------------------------------------------------------------------
    447          Function DebugRxCallback()
    448          
    449          Description:
    450          Call back function used when character received.
    451          
    452          Requires:
    453            - None
    454          
    455          Promises:
    456            - Safely advances Debug_pu8RxBufferNextChar.
    457          */

   \                                 In section .text, align 4, keep-with-next
    458          void DebugRxCallback(void)
    459          {
    460            /* Safely advance the NextChar pointer */
    461            Debug_pu8RxBufferNextChar++;
   \                     DebugRxCallback: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable15_13
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    462            if(Debug_pu8RxBufferNextChar == &Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15_17
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??DebugRxCallback_0
    463            {
    464              Debug_pu8RxBufferNextChar = &Debug_au8RxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable15_13
   \   00000024   0x6008             STR      R0,[R1, #+0]
    465            }
    466            
    467          } /* end DebugRxCallback() */
   \                     ??DebugRxCallback_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    468          
    469          
    470          /*--------------------------------------------------------------------------------------------------------------------*/
    471          /* Private Functions */
    472          /*--------------------------------------------------------------------------------------------------------------------*/
    473          
    474          /*----------------------------------------------------------------------------------------------------------------------
    475          Function DebugCommandPrepareList
    476          
    477          Description:
    478          Queues the entire list of debug commands available in the system so they will
    479          be sent out the debug UART for the user to view.
    480          
    481          Requires:
    482            - Message Sender application is running
    483          
    484          Promises:
    485            - Command numbers and names of all installed commands are queued to messagesender.
    486          */

   \                                 In section .text, align 2, keep-with-next
    487          static void DebugCommandPrepareList(void)
    488          {
   \                     DebugCommandPrepareList: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
    489            u8 au8ListHeading[] = "\n\n\rAvailable commands:\n\r";
   \   00000004   0xA80A             ADD      R0,SP,#+40
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_18
   \   0000000A   0x2219             MOVS     R2,#+25
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    490            u8 au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + DEBUG_CMD_POSTFIX_LENGTH];
    491            
    492            /* Write static characters to command list line */
    493            au8CommandLine[2] = ':';
   \   00000010   0x203A             MOVS     R0,#+58
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
    494            au8CommandLine[3] = ' ';
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    495            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH] = '\n';
   \   0000001C   0x200A             MOVS     R0,#+10
   \   0000001E   0xF88D 0x0024      STRB     R0,[SP, #+36]
    496            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + 1] = '\r';
   \   00000022   0x200D             MOVS     R0,#+13
   \   00000024   0xF88D 0x0025      STRB     R0,[SP, #+37]
    497            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + 2] = '\0';
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0026      STRB     R0,[SP, #+38]
    498          
    499            /* Prepare a nicely formatted list of commands */
    500            DebugPrintf(au8ListHeading);
   \   0000002E   0xA80A             ADD      R0,SP,#+40
   \   00000030   0x.... 0x....      BL       DebugPrintf
    501            
    502            /* Loop through the array of commands parsing out the command number
    503            and printing it along with the command name. */  
    504            for(u8 i = 0; i < DEBUG_COMMANDS; i++)
   \   00000034   0x2400             MOVS     R4,#+0
   \                     ??DebugCommandPrepareList_0: (+1)
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2C08             CMP      R4,#+8
   \   0000003A   0xDA2C             BGE.N    ??DebugCommandPrepareList_1
    505            {
    506              /* Get the command number in ASCII */
    507              if(i >= 10)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C0A             CMP      R4,#+10
   \   00000040   0xDB07             BLT.N    ??DebugCommandPrepareList_2
    508              {
    509                au8CommandLine[0] = (i / 10) + 0x30;
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x200A             MOVS     R0,#+10
   \   00000046   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   0000004A   0x3030             ADDS     R0,R0,#+48
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000050   0xE002             B.N      ??DebugCommandPrepareList_3
    510              }
    511              else
    512              {
    513                au8CommandLine[0] = 0x30;
   \                     ??DebugCommandPrepareList_2: (+1)
   \   00000052   0x2030             MOVS     R0,#+48
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    514              }
    515              
    516              au8CommandLine[1] = (i % 10) + 0x30;
   \                     ??DebugCommandPrepareList_3: (+1)
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x200A             MOVS     R0,#+10
   \   0000005C   0xFB94 0xF1F0      SDIV     R1,R4,R0
   \   00000060   0xFB00 0x4011      MLS      R0,R0,R1,R4
   \   00000064   0x3030             ADDS     R0,R0,#+48
   \   00000066   0xF88D 0x0001      STRB     R0,[SP, #+1]
    517              
    518              /* Read the command name */
    519              for(u8 j = 0; j < DEBUG_CMD_NAME_LENGTH; j++)
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??DebugCommandPrepareList_4: (+1)
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x2820             CMP      R0,#+32
   \   00000070   0xDA0C             BGE.N    ??DebugCommandPrepareList_5
    520              {
    521                au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + j] = Debug_au8Commands[i].pu8CommandName[j];
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable15_19
   \   00000076   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000078   0xF851 0x1034      LDR      R1,[R1, R4, LSL #+3]
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x5C41             LDRB     R1,[R0, R1]
   \   00000080   0xAA00             ADD      R2,SP,#+0
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x1882             ADDS     R2,R0,R2
   \   00000086   0x7111             STRB     R1,[R2, #+4]
    522              }
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0xE7EF             B.N      ??DebugCommandPrepareList_4
    523              
    524              /* Queue the command name to the UART */
    525              DebugPrintf(au8CommandLine);
   \                     ??DebugCommandPrepareList_5: (+1)
   \   0000008C   0xA800             ADD      R0,SP,#+0
   \   0000008E   0x.... 0x....      BL       DebugPrintf
    526            }
   \   00000092   0x1C64             ADDS     R4,R4,#+1
   \   00000094   0xE7CF             B.N      ??DebugCommandPrepareList_0
    527          
    528            DebugLineFeed();
   \                     ??DebugCommandPrepareList_1: (+1)
   \   00000096   0x.... 0x....      BL       DebugLineFeed
    529            
    530          } /* end DebugCommand0PrepareList() */
   \   0000009A   0xB012             ADD      SP,SP,#+72
   \   0000009C   0xBD10             POP      {R4,PC}          ;; return
    531          
    532          
    533          
    534          /*----------------------------------------------------------------------------------------------------------------------
    535          Function: DebugCommandDummy
    536          
    537          Description:
    538          A command place-holder.
    539          */

   \                                 In section .text, align 2, keep-with-next
    540          static void DebugCommandDummy(void)
    541          {
   \                     DebugCommandDummy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    542            u8 au8DummyCommand[] = "\n\rDummy!\n\n\r";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_20
   \   0000000A   0xC91C             LDM      R1!,{R2-R4}
   \   0000000C   0xC01C             STM      R0!,{R2-R4}
   \   0000000E   0x390C             SUBS     R1,R1,#+12
   \   00000010   0x380C             SUBS     R0,R0,#+12
    543            
    544            DebugPrintf(au8DummyCommand);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       DebugPrintf
    545            
    546          } /* end DebugCommandDummy() */
   \   00000018   0xBD1F             POP      {R0-R4,PC}       ;; return
    547          
    548          
    549          /*----------------------------------------------------------------------------------------------------------------------
    550          Function: DebugCommandLedTestToggle
    551          
    552          Description:
    553          Toggles the active state of the LED test which allows typed characters corresponding to LED colors
    554          to toggle those LEDs on or off.  LEDs are started all ON.  They are left in their current state when
    555          the function exits.
    556          */

   \                                 In section .text, align 2, keep-with-next
    557          static void DebugCommandLedTestToggle(void)
    558          {
   \                     DebugCommandLedTestToggle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    559            u8 au8LedTestMessage[] = "\n\rLed Test ";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_21
   \   0000000A   0xC91C             LDM      R1!,{R2-R4}
   \   0000000C   0xC01C             STM      R0!,{R2-R4}
   \   0000000E   0x390C             SUBS     R1,R1,#+12
   \   00000010   0x380C             SUBS     R0,R0,#+12
    560            
    561            /* Print message and toggle the flag */
    562            DebugPrintf(au8LedTestMessage);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       DebugPrintf
    563            if(G_u32DebugFlags & _DEBUG_LED_TEST_ENABLE)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable15_22
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD50C             BPL.N    ??DebugCommandLedTestToggle_0
    564            {
    565              G_u32DebugFlags &= ~_DEBUG_LED_TEST_ENABLE;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable15_22
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0x0040             LSLS     R0,R0,#+1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable15_22
   \   00000030   0x6008             STR      R0,[R1, #+0]
    566              DebugPrintf(G_au8MessageOFF);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable15_23
   \   00000036   0x.... 0x....      BL       DebugPrintf
   \   0000003A   0xE03B             B.N      ??DebugCommandLedTestToggle_1
    567            }
    568            else
    569            {
    570              G_u32DebugFlags |= _DEBUG_LED_TEST_ENABLE;
   \                     ??DebugCommandLedTestToggle_0: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable15_22
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable15_22
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    571              DebugPrintf(G_au8MessageON);
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable15_24
   \   00000050   0x.... 0x....      BL       DebugPrintf
    572              
    573          #ifdef MPG1
    574              LedOn(WHITE);
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      BL       LedOn
    575              LedOn(PURPLE);
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       LedOn
    576              LedOn(BLUE);
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x.... 0x....      BL       LedOn
    577              LedOn(CYAN);
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0x.... 0x....      BL       LedOn
    578              LedOn(GREEN);
   \   0000006C   0x2004             MOVS     R0,#+4
   \   0000006E   0x.... 0x....      BL       LedOn
    579              LedOn(YELLOW);
   \   00000072   0x2005             MOVS     R0,#+5
   \   00000074   0x.... 0x....      BL       LedOn
    580              LedOn(ORANGE);
   \   00000078   0x2006             MOVS     R0,#+6
   \   0000007A   0x.... 0x....      BL       LedOn
    581              LedOn(RED);
   \   0000007E   0x2007             MOVS     R0,#+7
   \   00000080   0x.... 0x....      BL       LedOn
    582          #endif /* MPG 1 */   
    583              
    584              #ifdef MPG1
    585              LedOn(WHITE);
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      BL       LedOn
    586              LedOn(PURPLE);
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      BL       LedOn
    587              LedOn(BLUE);
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0x.... 0x....      BL       LedOn
    588              LedOn(CYAN);
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0x.... 0x....      BL       LedOn
    589              LedOn(GREEN);
   \   0000009C   0x2004             MOVS     R0,#+4
   \   0000009E   0x.... 0x....      BL       LedOn
    590              LedOn(YELLOW);
   \   000000A2   0x2005             MOVS     R0,#+5
   \   000000A4   0x.... 0x....      BL       LedOn
    591              LedOn(ORANGE);
   \   000000A8   0x2006             MOVS     R0,#+6
   \   000000AA   0x.... 0x....      BL       LedOn
    592              LedOn(RED);
   \   000000AE   0x2007             MOVS     R0,#+7
   \   000000B0   0x.... 0x....      BL       LedOn
    593          #endif /* MPG 1 */
    594          
    595          #ifdef MPGL2
    596          #ifdef MPGL2_R01
    597              LedOn(BLUE);
    598              LedOn(GREEN);
    599              LedOn(YELLOW);
    600              LedOn(RED);
    601          #else
    602              LedOn(BLUE0);
    603              LedOn(BLUE1);
    604              LedOn(BLUE2);
    605              LedOn(BLUE3);
    606              LedOn(RED0);
    607              LedOn(RED1);
    608              LedOn(RED2);
    609              LedOn(RED3);
    610              LedOn(GREEN0);
    611              LedOn(GREEN1);
    612              LedOn(GREEN2);
    613              LedOn(GREEN3);
    614          #endif /* MPGL2_R01 */
    615          #endif /* MPGL2 */
    616            }
    617            
    618          } /* end DebugCommandLedTestToggle() */
   \                     ??DebugCommandLedTestToggle_1: (+1)
   \   000000B4   0xBD1F             POP      {R0-R4,PC}       ;; return
    619          
    620          
    621          /*----------------------------------------------------------------------------------------------------------------------
    622          Function: DebugLedTestCharacter
    623          
    624          Description:
    625          Checks the character and toggles associated LED if applicable.
    626          This implementation is specific to the target hardware.
    627          
    628          Requires:
    629            - u8Char_ is the character to check
    630          
    631          Promises:
    632            - If u8Char_ is a valid toggling character, the corresponding LED will be toggled.
    633          */

   \                                 In section .text, align 2, keep-with-next
    634          static void DebugLedTestCharacter(u8 u8Char_)
    635          {
   \                     DebugLedTestCharacter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    636            /* Check the char to see if an LED should be toggled */  
    637          #ifdef MPGL1
    638            if(u8Char_ == 'W')
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C57             CMP      R4,#+87
   \   00000008   0xD102             BNE.N    ??DebugLedTestCharacter_0
    639            {
    640              LedToggle(WHITE);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       LedToggle
    641            }  
    642          
    643            if(u8Char_ == 'P')
   \                     ??DebugLedTestCharacter_0: (+1)
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C50             CMP      R4,#+80
   \   00000014   0xD102             BNE.N    ??DebugLedTestCharacter_1
    644            {
    645              LedToggle(PURPLE);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       LedToggle
    646            } 
    647          
    648            if(u8Char_ == 'B')
   \                     ??DebugLedTestCharacter_1: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C42             CMP      R4,#+66
   \   00000020   0xD102             BNE.N    ??DebugLedTestCharacter_2
    649            {
    650              LedToggle(BLUE);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       LedToggle
    651            } 
    652          
    653            if(u8Char_ == 'C')
   \                     ??DebugLedTestCharacter_2: (+1)
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C43             CMP      R4,#+67
   \   0000002C   0xD102             BNE.N    ??DebugLedTestCharacter_3
    654            {
    655              LedToggle(CYAN);
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x.... 0x....      BL       LedToggle
    656            } 
    657          
    658            if(u8Char_ == 'G')
   \                     ??DebugLedTestCharacter_3: (+1)
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C47             CMP      R4,#+71
   \   00000038   0xD102             BNE.N    ??DebugLedTestCharacter_4
    659            {
    660              LedToggle(GREEN);
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x.... 0x....      BL       LedToggle
    661            } 
    662          
    663            if(u8Char_ == 'Y')
   \                     ??DebugLedTestCharacter_4: (+1)
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x2C59             CMP      R4,#+89
   \   00000044   0xD102             BNE.N    ??DebugLedTestCharacter_5
    664            {
    665              LedToggle(YELLOW);
   \   00000046   0x2005             MOVS     R0,#+5
   \   00000048   0x.... 0x....      BL       LedToggle
    666            } 
    667          
    668            if(u8Char_ == 'O')
   \                     ??DebugLedTestCharacter_5: (+1)
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x2C4F             CMP      R4,#+79
   \   00000050   0xD102             BNE.N    ??DebugLedTestCharacter_6
    669            {
    670              LedToggle(ORANGE);
   \   00000052   0x2006             MOVS     R0,#+6
   \   00000054   0x.... 0x....      BL       LedToggle
    671            } 
    672          
    673            if(u8Char_ == 'R')
   \                     ??DebugLedTestCharacter_6: (+1)
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x2C52             CMP      R4,#+82
   \   0000005C   0xD102             BNE.N    ??DebugLedTestCharacter_7
    674            {
    675              LedToggle(RED);
   \   0000005E   0x2007             MOVS     R0,#+7
   \   00000060   0x.... 0x....      BL       LedToggle
    676            } 
    677          
    678          #endif /* MPGL1 */
    679            
    680          #ifdef MPGL2
    681            
    682          #ifdef MPGL2_R01
    683            if(u8Char_ == 'B')
    684            {
    685              LedToggle(BLUE);
    686            } 
    687          
    688            if(u8Char_ == 'G')
    689            {
    690              LedToggle(GREEN);
    691            } 
    692          
    693            if(u8Char_ == 'Y')
    694            {
    695              LedToggle(YELLOW);
    696            } 
    697          
    698            if(u8Char_ == 'R')
    699            {
    700              LedToggle(RED);
    701            } 
    702            
    703          #else
    704          
    705            if(u8Char_ == 'B')
    706            {
    707              LedToggle(BLUE0);
    708              LedToggle(BLUE1);
    709              LedToggle(BLUE2);
    710              LedToggle(BLUE3);
    711            }  
    712          
    713            if(u8Char_ == 'R')
    714            {
    715              LedToggle(RED0);
    716              LedToggle(RED1);
    717              LedToggle(RED2);
    718              LedToggle(RED3);
    719            }  
    720            
    721            if(u8Char_ == 'G')
    722            {
    723              LedToggle(GREEN0);
    724              LedToggle(GREEN1);
    725              LedToggle(GREEN2);
    726              LedToggle(GREEN3);
    727            }  
    728           
    729          #endif /* MPGL2_R01 */
    730          #endif /* MPGL2 */
    731            
    732          } /* end DebugCommandLedTestToggle() */
   \                     ??DebugLedTestCharacter_7: (+1)
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
    733          
    734          
    735          /*----------------------------------------------------------------------------------------------------------------------
    736          Function: DebugCommandSysTimeToggle
    737          
    738          Description:
    739          Toggles the active state of the LED test which allows typed characters corresponding to LED colors
    740          to toggle those LEDs on or off.
    741          */

   \                                 In section .text, align 2, keep-with-next
    742          static void DebugCommandSysTimeToggle(void)
    743          {
   \                     DebugCommandSysTimeToggle: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    744            u8 au8SysTimeTestMessage[] = "\n\rSystem time violation reporting ";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable15_25
   \   00000008   0x2223             MOVS     R2,#+35
   \   0000000A   0x.... 0x....      BL       __aeabi_memcpy
    745            
    746            /* Print message and toggle the flag */
    747            DebugPrintf(au8SysTimeTestMessage);
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x.... 0x....      BL       DebugPrintf
    748            if(G_u32DebugFlags & _DEBUG_TIME_WARNING_ENABLE)
   \   00000014   0x....             LDR.N    R0,??DataTable15_22
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x07C0             LSLS     R0,R0,#+31
   \   0000001A   0xD509             BPL.N    ??DebugCommandSysTimeToggle_0
    749            {
    750              G_u32DebugFlags &= ~_DEBUG_TIME_WARNING_ENABLE;
   \   0000001C   0x....             LDR.N    R0,??DataTable15_22
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x0840             LSRS     R0,R0,#+1
   \   00000022   0x0040             LSLS     R0,R0,#+1
   \   00000024   0x....             LDR.N    R1,??DataTable15_22
   \   00000026   0x6008             STR      R0,[R1, #+0]
    751              DebugPrintf(G_au8MessageOFF);
   \   00000028   0x....             LDR.N    R0,??DataTable15_23
   \   0000002A   0x.... 0x....      BL       DebugPrintf
   \   0000002E   0xE008             B.N      ??DebugCommandSysTimeToggle_1
    752            }
    753            else
    754            {
    755              G_u32DebugFlags |= _DEBUG_TIME_WARNING_ENABLE;
   \                     ??DebugCommandSysTimeToggle_0: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable15_22
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000038   0x....             LDR.N    R1,??DataTable15_22
   \   0000003A   0x6008             STR      R0,[R1, #+0]
    756              DebugPrintf(G_au8MessageON);
   \   0000003C   0x....             LDR.N    R0,??DataTable15_24
   \   0000003E   0x.... 0x....      BL       DebugPrintf
    757            }
    758            
    759          } /* end DebugCommandSysTimeToggle() */
   \                     ??DebugCommandSysTimeToggle_1: (+1)
   \   00000042   0xB009             ADD      SP,SP,#+36
   \   00000044   0xBD00             POP      {PC}             ;; return
    760          
    761          #ifdef MPGL2 /* MPGL2 only tests */
    762          /*----------------------------------------------------------------------------------------------------------------------
    763          Function: DebugCommandCaptouchValuesToggle
    764          
    765          Description:
    766          Toggles printing the current Captouch horizontal and vertical values.
    767          */
    768          static void DebugCommandCaptouchValuesToggle(void)
    769          {
    770            u8 au8CaptouchDisplayMessage[] = "\n\rDisplay Captouch values ";
    771            u8 au8CaptouchOnMessage[] = "No values displayed if Captouch is OFF\n\r";
    772            
    773            /* Print message and toggle the flag */
    774            DebugPrintf(au8CaptouchDisplayMessage);
    775            if(G_u32DebugFlags & _DEBUG_CAPTOUCH_VALUES_ENABLE)
    776            {
    777              G_u32DebugFlags &= ~_DEBUG_CAPTOUCH_VALUES_ENABLE;
    778              DebugPrintf(G_au8MessageOFF);
    779            }
    780            else
    781            {
    782              G_u32DebugFlags |= _DEBUG_CAPTOUCH_VALUES_ENABLE;
    783              DebugPrintf(G_au8MessageON);
    784              DebugPrintf(au8CaptouchOnMessage);
    785            }
    786            
    787          } /* end DebugCommandCaptouchValuesToggle() */
    788          #endif /* MPGL2 only tests */
    789          
    790          
    791          /***********************************************************************************************************************
    792          State Machine Function Declarations
    793          
    794          The debugger state machine monitors the receive buffer to grab characters as they come in
    795          from the interrupt-driven receiver and store them in the debug command buffer.  Nothing happens 
    796          until the user sends a CR indicating they think they've entered a valid command.  The command is
    797          checked and reacted to accordingly.
    798          ***********************************************************************************************************************/
    799          
    800          /*----------------------------------------------------------------------------------------------------------------------
    801          Waits for a byte to appear in the Rx buffer.  The BufferParser is always moved
    802          through all new characters placing them into the command buffer until it hits a CR or there are no new
    803          characters to read. If there is no CR in this iteration, nothing else occurs.
    804          
    805          Backspace: Echo the backspace and a space character to clear the character on screen; move Debug_pu8BufferCurrentChar back.
    806          CR: Advance states to process the command.
    807          Any other character: Echo it to the UART Tx and place a copy in Debug_au8CommandBuffer.
    808          */

   \                                 In section .text, align 4, keep-with-next
    809          void DebugSM_Idle(void)               
    810          {
   \                     DebugSM_Idle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    811            bool bCommandFound = FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
    812            u8 u8CurrentByte;
    813            static u8 au8BackspaceSequence[] = {ASCII_BACKSPACE, ' ', ASCII_BACKSPACE};
    814            static u8 au8CommandOverflow[] = "\r\n*** Command too long ***\r\n\n";
    815            
    816            /* Parse any new characters that have come in until no more chars or a command is found */
    817            while( (Debug_pu8RxBufferParser != Debug_pu8RxBufferNextChar) && (bCommandFound == FALSE) )
   \                     ??DebugSM_Idle_0: (+1)
   \   00000004   0x....             LDR.N    R0,??DataTable15_12
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable15_13
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xF000 0x807F      BEQ.W    ??DebugSM_Idle_1
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD17B             BNE.N    ??DebugSM_Idle_1
    818            {
    819              /* Grab a copy of the current byte and echo it back */
    820              u8CurrentByte = *Debug_pu8RxBufferParser;
   \   00000018   0x....             LDR.N    R0,??DataTable15_12
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x0005             MOVS     R5,R0
    821              
    822              /* If the LED test is active, toggle LEDs based on characters */
    823              if(G_u32DebugFlags & _DEBUG_LED_TEST_ENABLE)
   \   00000020   0x....             LDR.N    R0,??DataTable15_22
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xD503             BPL.N    ??DebugSM_Idle_2
    824              {
    825                DebugLedTestCharacter(u8CurrentByte);
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x.... 0x....      BL       DebugLedTestCharacter
    826              }
    827              
    828              /* Process the character */
    829              switch (u8CurrentByte)
   \                     ??DebugSM_Idle_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xD002             BEQ.N    ??DebugSM_Idle_3
   \   00000038   0x280D             CMP      R0,#+13
   \   0000003A   0xD021             BEQ.N    ??DebugSM_Idle_4
   \   0000003C   0xE026             B.N      ??DebugSM_Idle_5
    830              {
    831                /* Backspace: update command buffer pointer and send sequence to delete the char on the terminal */
    832                case(ASCII_BACKSPACE): 
    833                {
    834                  /* Process for scanf */
    835                  if(G_u8DebugScanfCharCount != 0)
   \                     ??DebugSM_Idle_3: (+1)
   \   0000003E   0x....             LDR.N    R0,??DataTable15_5
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD009             BEQ.N    ??DebugSM_Idle_6
    836                  {
    837                    G_u8DebugScanfCharCount--;
   \   00000046   0x....             LDR.N    R0,??DataTable15_5
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0x....             LDR.N    R1,??DataTable15_5
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    838                    G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = '\0';
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x....             LDR.N    R1,??DataTable15_6
   \   00000054   0x....             LDR.N    R2,??DataTable15_5
   \   00000056   0x7812             LDRB     R2,[R2, #+0]
   \   00000058   0x5450             STRB     R0,[R2, R1]
    839                  }
    840                  
    841                  /* Process for command */
    842                  if(Debug_pu8CmdBufferNextChar != &Debug_au8CommandBuffer[0])
   \                     ??DebugSM_Idle_6: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable15_15
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x....             LDR.N    R1,??DataTable15_14
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD009             BEQ.N    ??DebugSM_Idle_7
    843                  {
    844                    Debug_pu8CmdBufferNextChar--;
   \   00000064   0x....             LDR.N    R0,??DataTable15_15
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x1E40             SUBS     R0,R0,#+1
   \   0000006A   0x....             LDR.N    R1,??DataTable15_15
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    845                    Debug_u16CommandSize--;
   \   0000006E   0x....             LDR.N    R0,??DataTable15_26
   \   00000070   0x8800             LDRH     R0,[R0, #+0]
   \   00000072   0x1E40             SUBS     R0,R0,#+1
   \   00000074   0x....             LDR.N    R1,??DataTable15_26
   \   00000076   0x8008             STRH     R0,[R1, #+0]
    846                  }
    847                  
    848                  DebugPrintf(au8BackspaceSequence);
   \                     ??DebugSM_Idle_7: (+1)
   \   00000078   0x....             LDR.N    R0,??DataTable15_27
   \   0000007A   0x.... 0x....      BL       DebugPrintf
    849                  break;
   \   0000007E   0xE038             B.N      ??DebugSM_Idle_8
    850                }
    851          
    852                /* Carriage return: change states to process new command and fall through to echo character */
    853                case(ASCII_CARRIAGE_RETURN): 
    854                {
    855                  bCommandFound = TRUE;
   \                     ??DebugSM_Idle_4: (+1)
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x0004             MOVS     R4,R0
    856                  Debug_pfnStateMachine = DebugSM_CheckCmd;
   \   00000084   0x.... 0x....      ADR.W    R0,DebugSM_CheckCmd
   \   00000088   0x....             LDR.N    R1,??DataTable15_4
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    857                  
    858                  /* Fall through to default */        
    859                }
    860                  
    861                /* Add to command buffer and echo */
    862                default: 
    863                {
    864                  /* Process for scanf */
    865                  if(G_u8DebugScanfCharCount < DEBUG_SCANF_BUFFER_SIZE)
   \                     ??DebugSM_Idle_5: (+1)
   \   0000008C   0x....             LDR.N    R0,??DataTable15_5
   \   0000008E   0x7800             LDRB     R0,[R0, #+0]
   \   00000090   0x2880             CMP      R0,#+128
   \   00000092   0xDA08             BGE.N    ??DebugSM_Idle_9
    866                  {
    867                    G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = u8CurrentByte;
   \   00000094   0x....             LDR.N    R0,??DataTable15_6
   \   00000096   0x....             LDR.N    R1,??DataTable15_5
   \   00000098   0x7809             LDRB     R1,[R1, #+0]
   \   0000009A   0x540D             STRB     R5,[R1, R0]
    868                    G_u8DebugScanfCharCount++;
   \   0000009C   0x....             LDR.N    R0,??DataTable15_5
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x1C40             ADDS     R0,R0,#+1
   \   000000A2   0x....             LDR.N    R1,??DataTable15_5
   \   000000A4   0x7008             STRB     R0,[R1, #+0]
    869                  }
    870                  
    871                  /* Echo the character and place it in the command buffer */
    872                  UartWriteByte(Debug_Uart, u8CurrentByte);
   \                     ??DebugSM_Idle_9: (+1)
   \   000000A6   0x0029             MOVS     R1,R5
   \   000000A8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000AA   0x....             LDR.N    R0,??DataTable15
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x.... 0x....      BL       UartWriteByte
    873                  *Debug_pu8CmdBufferNextChar = u8CurrentByte;
   \   000000B2   0x....             LDR.N    R0,??DataTable15_15
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x7005             STRB     R5,[R0, #+0]
    874                  Debug_pu8CmdBufferNextChar++;
   \   000000B8   0x....             LDR.N    R0,??DataTable15_15
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0x1C40             ADDS     R0,R0,#+1
   \   000000BE   0x....             LDR.N    R1,??DataTable15_15
   \   000000C0   0x6008             STR      R0,[R1, #+0]
    875                  Debug_u16CommandSize++;
   \   000000C2   0x....             LDR.N    R0,??DataTable15_26
   \   000000C4   0x8800             LDRH     R0,[R0, #+0]
   \   000000C6   0x1C40             ADDS     R0,R0,#+1
   \   000000C8   0x....             LDR.N    R1,??DataTable15_26
   \   000000CA   0x8008             STRH     R0,[R1, #+0]
    876          
    877                  /* If the command buffer is now full but the last character was not ASCII_CARRIAGE_RETURN, throw out the whole
    878                  buffer and report an error message */
    879                  if( (Debug_pu8CmdBufferNextChar >= &Debug_au8CommandBuffer[DEBUG_CMD_BUFFER_SIZE]) &&
    880                      (u8CurrentByte != ASCII_CARRIAGE_RETURN) )
   \   000000CC   0x....             LDR.N    R0,??DataTable15_15
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x....             LDR.N    R1,??DataTable15_28
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xD30D             BCC.N    ??DebugSM_Idle_10
   \   000000D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D8   0x2D0D             CMP      R5,#+13
   \   000000DA   0xD00A             BEQ.N    ??DebugSM_Idle_10
    881                  {
    882                    Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \   000000DC   0x....             LDR.N    R0,??DataTable15_14
   \   000000DE   0x....             LDR.N    R1,??DataTable15_15
   \   000000E0   0x6008             STR      R0,[R1, #+0]
    883                    Debug_u16CommandSize = 0;
   \   000000E2   0x2000             MOVS     R0,#+0
   \   000000E4   0x....             LDR.N    R1,??DataTable15_26
   \   000000E6   0x8008             STRH     R0,[R1, #+0]
    884          
    885                    Debug_u32CurrentMessageToken = DebugPrintf(au8CommandOverflow);
   \   000000E8   0x....             LDR.N    R0,??DataTable15_29
   \   000000EA   0x.... 0x....      BL       DebugPrintf
   \   000000EE   0x....             LDR.N    R1,??DataTable15_30
   \   000000F0   0x6008             STR      R0,[R1, #+0]
    886                  }
    887                  break;
    888                }
    889          
    890              } /* end switch (u8RxChar) */
    891                
    892              /* In all cases, advance the RxBufferParser pointer safely */
    893              Debug_pu8RxBufferParser++;
   \                     ??DebugSM_Idle_10: (+1)
   \                     ??DebugSM_Idle_8: (+1)
   \   000000F2   0x....             LDR.N    R0,??DataTable15_12
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0x1C40             ADDS     R0,R0,#+1
   \   000000F8   0x....             LDR.N    R1,??DataTable15_12
   \   000000FA   0x6008             STR      R0,[R1, #+0]
    894              if(Debug_pu8RxBufferParser >= &Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE])
   \   000000FC   0x....             LDR.N    R0,??DataTable15_12
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0x....             LDR.N    R1,??DataTable15_17
   \   00000102   0x4288             CMP      R0,R1
   \   00000104   0xF4FF 0xAF7E      BCC.W    ??DebugSM_Idle_0
    895              {
    896                Debug_pu8RxBufferParser = &Debug_au8RxBuffer[0];
   \   00000108   0x....             LDR.N    R0,??DataTable15_11
   \   0000010A   0x....             LDR.N    R1,??DataTable15_12
   \   0000010C   0x6008             STR      R0,[R1, #+0]
   \   0000010E   0xE779             B.N      ??DebugSM_Idle_0
    897              }
    898              
    899            } /* end while */
    900            
    901            /* Clear out any completed messages */
    902            if(Debug_u32CurrentMessageToken != 0)
   \                     ??DebugSM_Idle_1: (+1)
   \   00000110   0x....             LDR.N    R0,??DataTable15_30
   \   00000112   0x6800             LDR      R0,[R0, #+0]
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD003             BEQ.N    ??DebugSM_Idle_11
    903            {
    904              QueryMessageStatus(Debug_u32CurrentMessageToken);
   \   00000118   0x....             LDR.N    R0,??DataTable15_30
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0x.... 0x....      BL       QueryMessageStatus
    905            }
    906              
    907          } /* end DebugSM_Idle() */
   \                     ??DebugSM_Idle_11: (+1)
   \   00000120   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .data, align 4
   \                     ??au8BackspaceSequence:
   \   00000000   0x08 0x20          DC8 8, 32, 8, 0
   \              0x08 0x00    

   \                                 In section .data, align 4
   \                     ??au8CommandOverflow:
   \   00000000   0x0D 0x0A          DC8 "\015\012*** Command too long ***\015\012\012"
   \              0x2A 0x2A    
   \              0x2A 0x20    
   \              0x43 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x6C 0x6F    
   \              0x6E 0x67    
   \              0x20 0x2A    
   \              0x2A 0x2A    
   \              0x0D 0x0A    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0
    908          
    909          
    910          /*----------------------------------------------------------------------------------------------------------------------
    911          At the start of this state, the command buffer has a candidate command terminated in CR.
    912          There is a strict rule that commands are of the form
    913          en+cxx where xx is any number from 0 to DEBUG_COMMANDS, so parsing can be done based
    914          on that rule.  All other strings are invalid.  Debug interrupts remain off
    915          until the command is processed.
    916          */

   \                                 In section .text, align 4, keep-with-next
    917          void DebugSM_CheckCmd(void)        
    918          {
   \                     DebugSM_CheckCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    919            static u8 au8CommandHeader[] = "en+c";
    920            static u8 au8InvalidCommand[] = "\nInvalid command\n\n\r"; 
    921            bool bGoodCommand = TRUE;
   \   00000002   0x2401             MOVS     R4,#+1
    922            u8 u8Index;
    923            s8 s8Temp;
    924            
    925            /* Verify that the command starts with en+c */
    926            u8Index = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
    927            do
    928            {
    929              if(Debug_au8CommandBuffer[u8Index] != au8CommandHeader[u8Index])
   \                     ??DebugSM_CheckCmd_0: (+1)
   \   00000008   0x....             LDR.N    R0,??DataTable15_14
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x5C28             LDRB     R0,[R5, R0]
   \   0000000E   0x....             LDR.N    R1,??DataTable15_31
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x5C69             LDRB     R1,[R5, R1]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD001             BEQ.N    ??DebugSM_CheckCmd_1
    930              {
    931                bGoodCommand = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0004             MOVS     R4,R0
    932              }
    933          
    934              u8Index++;
   \                     ??DebugSM_CheckCmd_1: (+1)
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
    935            } while ( bGoodCommand && (u8Index < 4) );
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD002             BEQ.N    ??DebugSM_CheckCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D04             CMP      R5,#+4
   \   00000028   0xDBEE             BLT.N    ??DebugSM_CheckCmd_0
    936            
    937            /* On good header, read the command number */
    938            if(bGoodCommand)
   \                     ??DebugSM_CheckCmd_2: (+1)
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD02E             BEQ.N    ??DebugSM_CheckCmd_3
    939            {
    940              /* Make an assumption */
    941              bGoodCommand = FALSE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0004             MOVS     R4,R0
    942          
    943              /* Verify the next char is a digit */
    944              s8Temp = Debug_au8CommandBuffer[u8Index++] - 0x30;
   \   00000034   0x....             LDR.N    R0,??DataTable15_14
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x5628             LDRSB    R0,[R5, R0]
   \   0000003A   0x3830             SUBS     R0,R0,#+48
   \   0000003C   0x0006             MOVS     R6,R0
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
    945            
    946              if( (s8Temp >= 0) && (s8Temp <= 9) )
   \   00000040   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD423             BMI.N    ??DebugSM_CheckCmd_3
   \   00000046   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000048   0x2E0A             CMP      R6,#+10
   \   0000004A   0xDA20             BGE.N    ??DebugSM_CheckCmd_3
    947              {
    948                Debug_u8Command = s8Temp * 10;
   \   0000004C   0x200A             MOVS     R0,#+10
   \   0000004E   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000052   0x....             LDR.N    R1,??DataTable15_32
   \   00000054   0x7008             STRB     R0,[R1, #+0]
    949            
    950                /* Verify the next char is a digit */
    951                s8Temp = Debug_au8CommandBuffer[u8Index++] - 0x30;
   \   00000056   0x....             LDR.N    R0,??DataTable15_14
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x5628             LDRSB    R0,[R5, R0]
   \   0000005C   0x3830             SUBS     R0,R0,#+48
   \   0000005E   0x0006             MOVS     R6,R0
   \   00000060   0x1C6D             ADDS     R5,R5,#+1
    952                if( (s8Temp >= 0) && (s8Temp <= 9) )
   \   00000062   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD412             BMI.N    ??DebugSM_CheckCmd_3
   \   00000068   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   0000006A   0x2E0A             CMP      R6,#+10
   \   0000006C   0xDA0F             BGE.N    ??DebugSM_CheckCmd_3
    953                {
    954                  Debug_u8Command += s8Temp;
   \   0000006E   0x....             LDR.N    R0,??DataTable15_32
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x1830             ADDS     R0,R6,R0
   \   00000074   0x....             LDR.N    R1,??DataTable15_32
   \   00000076   0x7008             STRB     R0,[R1, #+0]
    955                  
    956                  /* Check that the command number is within the range of commands available and the last char is CR */
    957                  if( (Debug_u8Command < DEBUG_COMMANDS) && (Debug_au8CommandBuffer[u8Index] == ASCII_CARRIAGE_RETURN) )
   \   00000078   0x....             LDR.N    R0,??DataTable15_32
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x2808             CMP      R0,#+8
   \   0000007E   0xDA06             BGE.N    ??DebugSM_CheckCmd_3
   \   00000080   0x....             LDR.N    R0,??DataTable15_14
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x5C28             LDRB     R0,[R5, R0]
   \   00000086   0x280D             CMP      R0,#+13
   \   00000088   0xD101             BNE.N    ??DebugSM_CheckCmd_3
    958                  {
    959                    bGoodCommand = TRUE;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x0004             MOVS     R4,R0
    960                  }
    961                }
    962              }
    963            }
    964                     
    965            /* If still good command */
    966            if( bGoodCommand )
   \                     ??DebugSM_CheckCmd_3: (+1)
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xD004             BEQ.N    ??DebugSM_CheckCmd_4
    967            {
    968              Debug_pfnStateMachine = DebugSM_ProcessCmd;
   \   00000094   0x.... 0x....      ADR.W    R0,DebugSM_ProcessCmd
   \   00000098   0x....             LDR.N    R1,??DataTable15_4
   \   0000009A   0x6008             STR      R0,[R1, #+0]
   \   0000009C   0xE005             B.N      ??DebugSM_CheckCmd_5
    969            }
    970            /* Otherwise print an error message and return to Idle */
    971            else
    972            { 
    973              DebugPrintf(au8InvalidCommand);
   \                     ??DebugSM_CheckCmd_4: (+1)
   \   0000009E   0x....             LDR.N    R0,??DataTable15_33
   \   000000A0   0x.... 0x....      BL       DebugPrintf
    974              Debug_pfnStateMachine = DebugSM_Idle;
   \   000000A4   0x....             LDR.N    R0,??DataTable15_34
   \   000000A6   0x....             LDR.N    R1,??DataTable15_4
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    975            }
    976          
    977            /* Reset the command buffer */
    978            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \                     ??DebugSM_CheckCmd_5: (+1)
   \   000000AA   0x....             LDR.N    R0,??DataTable15_14
   \   000000AC   0x....             LDR.N    R1,??DataTable15_15
   \   000000AE   0x6008             STR      R0,[R1, #+0]
    979          
    980          } /* end DebugSM_CheckCmd() */
   \   000000B0   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8CommandHeader:
   \   00000000   0x65 0x6E          DC8 "en+c"
   \              0x2B 0x63    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     ??au8InvalidCommand:
   \   00000000   0x0A 0x49          DC8 "\012Invalid command\012\012\015"
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x0A 0x0A    
   \              0x0D 0x00    
    981          
    982          
    983          /*----------------------------------------------------------------------------------------------------------------------
    984          Carry out the debug instruction. 
    985          */

   \                                 In section .text, align 4, keep-with-next
    986          void DebugSM_ProcessCmd(void)         
    987          {
   \                     DebugSM_ProcessCmd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    988            /* Setup for return to Idle state */
    989            Debug_pfnStateMachine = DebugSM_Idle;
   \   00000002   0x....             LDR.N    R0,??DataTable15_34
   \   00000004   0x....             LDR.N    R1,??DataTable15_4
   \   00000006   0x6008             STR      R0,[R1, #+0]
    990          
    991            /* Call the command function in the function array (may change next state ) */
    992            Debug_au8Commands[Debug_u8Command].DebugFunction();
   \   00000008   0x....             LDR.N    R0,??DataTable15_19
   \   0000000A   0x....             LDR.N    R1,??DataTable15_32
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0x4780             BLX      R0
    993            
    994          } /* end DebugSM_ProcessCmd() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    995          
    996          
    997          /*----------------------------------------------------------------------------------------------------------------------
    998          Error state 
    999          Attempt to print an error message (even though if the Debug UART has failed, then it obviously cannot print
   1000          a message to tell you that!)
   1001          */

   \                                 In section .text, align 4, keep-with-next
   1002          void DebugSM_Error(void)         
   1003          {
   \                     DebugSM_Error: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1004            static u8 au8DebugErrorMsg[] = "\n\nDebug task error: ";
   1005            
   1006            /* Flag an error and report it (if possible) */
   1007            G_u32DebugFlags |= _DEBUG_FLAG_ERROR;
   \   00000002   0x....             LDR.N    R0,??DataTable15_22
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000000A   0x....             LDR.N    R1,??DataTable15_22
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   1008            DebugPrintf(au8DebugErrorMsg);
   \   0000000E   0x....             LDR.N    R0,??DataTable15_35
   \   00000010   0x.... 0x....      BL       DebugPrintf
   1009            DebugPrintNumber( (u32)(Debug_u8ErrorCode) );
   \   00000014   0x....             LDR.N    R0,??DataTable15_3
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x.... 0x....      BL       DebugPrintNumber
   1010            DebugLineFeed();
   \   0000001C   0x.... 0x....      BL       DebugLineFeed
   1011            
   1012            /* Return to Idle state */
   1013            Debug_u16CommandSize = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable15_26
   \   00000024   0x8008             STRH     R0,[R1, #+0]
   1014            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \   00000026   0x....             LDR.N    R0,??DataTable15_14
   \   00000028   0x....             LDR.N    R1,??DataTable15_15
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1015            Debug_pfnStateMachine = DebugSM_Idle;
   \   0000002C   0x....             LDR.N    R0,??DataTable15_34
   \   0000002E   0x....             LDR.N    R1,??DataTable15_4
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1016          
   1017          } /* end DebugSM_Error() */
   \   00000032   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .data, align 4
   \                     ??au8DebugErrorMsg:
   \   00000000   0x0A 0x0A          DC8 "\012\012Debug task error: "
   \              0x44 0x65    
   \              0x62 0x75    
   \              0x67 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     Debug_Uart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x3B9ACA00         DC32     0x3b9aca00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     Debug_u8ErrorCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     Debug_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x........         DC32     G_u8DebugScanfCharCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     G_au8DebugScanfBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x........         DC32     Debug_au8RxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x........         DC32     Debug_pu8RxBufferParser

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x........         DC32     Debug_pu8RxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x........         DC32     Debug_au8CommandBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0x........         DC32     Debug_pu8CmdBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   0x........         DC32     Debug_au8StartupMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   0x........         DC32     Debug_au8RxBuffer+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \   00000000   0x........         DC32     Debug_au8Commands

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_20:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_21:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_22:
   \   00000000   0x........         DC32     G_u32DebugFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_23:
   \   00000000   0x........         DC32     G_au8MessageOFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_24:
   \   00000000   0x........         DC32     G_au8MessageON

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_25:
   \   00000000   0x........         DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_26:
   \   00000000   0x........         DC32     Debug_u16CommandSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_27:
   \   00000000   0x........         DC32     ??au8BackspaceSequence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_28:
   \   00000000   0x........         DC32     Debug_au8CommandBuffer+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_29:
   \   00000000   0x........         DC32     ??au8CommandOverflow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_30:
   \   00000000   0x........         DC32     Debug_u32CurrentMessageToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_31:
   \   00000000   0x........         DC32     ??au8CommandHeader

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_32:
   \   00000000   0x........         DC32     Debug_u8Command

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_33:
   \   00000000   0x........         DC32     ??au8InvalidCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_34:
   \   00000000   0x........         DC32     DebugSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_35:
   \   00000000   0x........         DC32     ??au8DebugErrorMsg

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x53 0x68          DC8 "Show debug command list         "
   \              0x6F 0x77    
   \              0x20 0x64    
   \              0x65 0x62    
   \              0x75 0x67    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x20 0x6C    
   \              0x69 0x73    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x54 0x6F          DC8 "Toggle LED test                 "
   \              0x67 0x67    
   \              0x6C 0x65    
   \              0x20 0x4C    
   \              0x45 0x44    
   \              0x20 0x74    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x54 0x6F          DC8 "Toggle system timing warning    "
   \              0x67 0x67    
   \              0x6C 0x65    
   \              0x20 0x73    
   \              0x79 0x73    
   \              0x74 0x65    
   \              0x6D 0x20    
   \              0x74 0x69    
   \              0x6D 0x69    
   \              0x6E 0x67    
   \              0x20 0x77    
   \              0x61 0x72    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x44 0x75          DC8 "Dummy3                          "
   \              0x6D 0x6D    
   \              0x79 0x33    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x44 0x75          DC8 "Dummy4                          "
   \              0x6D 0x6D    
   \              0x79 0x34    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x44 0x75          DC8 "Dummy5                          "
   \              0x6D 0x6D    
   \              0x79 0x35    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x44 0x75          DC8 "Dummy6                          "
   \              0x6D 0x6D    
   \              0x79 0x36    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x44 0x75          DC8 "Dummy7                          "
   \              0x6D 0x6D    
   \              0x79 0x37    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \                     ?_8:
   \   00000000   0x0A 0x0D          DC8 10, 13

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x4E 0x4F          DC8 "NONE"
   \              0x4E 0x45    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x0A 0x0D          DC8 0AH, 0DH, 49H, 6EH, 69H, 74H, 69H, 61H
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \   00000008   0x6C 0x69          DC8 6CH, 69H, 7AH, 61H, 74H, 69H, 6FH, 6EH
   \              0x7A 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \   00000010   0x20 0x63          DC8 20H, 63H, 6FH, 6DH, 70H, 6CH, 65H, 74H
   \              0x6F 0x6D    
   \              0x70 0x6C    
   \              0x65 0x74    
   \   00000018   0x65 0x2E          DC8 65H, 2EH, 20H, 54H, 79H, 70H, 65H, 20H
   \              0x20 0x54    
   \              0x79 0x70    
   \              0x65 0x20    
   \   00000020   0x65 0x6E          DC8 65H, 6EH, 2BH, 63H, 30H, 30H, 20H, 66H
   \              0x2B 0x63    
   \              0x30 0x30    
   \              0x20 0x66    
   \   00000028   0x6F 0x72          DC8 6FH, 72H, 20H, 64H, 65H, 62H, 75H, 67H
   \              0x20 0x64    
   \              0x65 0x62    
   \              0x75 0x67    
   \   00000030   0x20 0x6D          DC8 20H, 6DH, 65H, 6EH, 75H, 2EH, 20H, 20H
   \              0x65 0x6E    
   \              0x75 0x2E    
   \              0x20 0x20    
   \   00000038   0x46 0x61          DC8 46H, 61H, 69H, 6CH, 65H, 64H, 20H, 74H
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \   00000040   0x61 0x73          DC8 61H, 73H, 6BH, 73H, 3AH, 0AH, 0DH, 0
   \              0x6B 0x73    
   \              0x3A 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x4C 0x45          DC8 "LED"
   \              0x44 0x00    
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000000A   0x42 0x55          DC8 "BUTTON"
   \              0x54 0x54    
   \              0x4F 0x4E    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   00000014   0x44 0x45          DC8 "DEBUG"
   \              0x42 0x55    
   \              0x47 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000001E   0x4C 0x43          DC8 "LCD"
   \              0x44 0x00    
   \   00000022   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x41 0x4E          DC8 "ANT"
   \              0x54 0x00    
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000032   0x53 0x44          DC8 "SD"
   \              0x00         
   \   00000035   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x0A 0x0A          DC8 "\012\012\015Available commands:\012\015"
   \              0x0D 0x41    
   \              0x76 0x61    
   \              0x69 0x6C    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x73 0x3A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x0A 0x0D          DC8 "\012\015Dummy!\012\012\015"
   \              0x44 0x75    
   \              0x6D 0x6D    
   \              0x79 0x21    
   \              0x0A 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x0A 0x0D          DC8 "\012\015Led Test "
   \              0x4C 0x65    
   \              0x64 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x0A 0x0D          DC8 "\012\015System time violation reporting "
   \              0x53 0x79    
   \              0x73 0x74    
   \              0x65 0x6D    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x20    
   \              0x76 0x69    
   \              0x6F 0x6C    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x72 0x65    
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x00         
   \   00000023   0x00               DC8 0
   1018                       
   1019          
   1020                    
   1021                       
   1022          /*--------------------------------------------------------------------------------------------------------------------*/
   1023          /* End of File                                                                                                        */
   1024          /*--------------------------------------------------------------------------------------------------------------------*/
   1025          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   DebugCommandDummy
        24   -> DebugPrintf
      24   DebugCommandLedTestToggle
        24   -> DebugPrintf
        24   -> LedOn
      80   DebugCommandPrepareList
        80   -> DebugLineFeed
        80   -> DebugPrintf
        80   -> __aeabi_memcpy
      40   DebugCommandSysTimeToggle
        40   -> DebugPrintf
        40   -> __aeabi_memcpy
      24   DebugInitialize
        24   -> DebugPrintf
        24   -> UartRequest
       8   DebugLedTestCharacter
         8   -> LedToggle
       8   DebugLineFeed
         8   -> UartWriteData
      40   DebugPrintNumber
        40   -> UartWriteData
        40   -> free
        40   -> malloc
      16   DebugPrintf
        16   -> UartWriteData
       8   DebugRunActiveState
         8   -- Indirect call
       0   DebugRxCallback
      16   DebugSM_CheckCmd
        16   -> DebugPrintf
       8   DebugSM_Error
         8   -> DebugLineFeed
         8   -> DebugPrintNumber
         8   -> DebugPrintf
      16   DebugSM_Idle
        16   -> DebugLedTestCharacter
        16   -> DebugPrintf
        16   -> QueryMessageStatus
        16   -> UartWriteByte
       8   DebugSM_ProcessCmd
         8   -- Indirect call
       4   DebugScanf
     160   SystemStatusReport
       160   -> DebugLineFeed
       160   -> DebugPrintf
       160   -> __aeabi_memcpy
       160   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_23
       4  ??DataTable15_24
       4  ??DataTable15_25
       4  ??DataTable15_26
       4  ??DataTable15_27
       4  ??DataTable15_28
       4  ??DataTable15_29
       4  ??DataTable15_3
       4  ??DataTable15_30
       4  ??DataTable15_31
       4  ??DataTable15_32
       4  ??DataTable15_33
       4  ??DataTable15_34
       4  ??DataTable15_35
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      36  ?_0
      36  ?_1
      72  ?_10
      60  ?_11
      28  ?_12
      12  ?_13
      12  ?_14
      36  ?_15
      36  ?_2
      36  ?_3
      36  ?_4
      36  ?_5
      36  ?_6
      36  ?_7
       2  ?_8
       8  ?_9
      26  DebugCommandDummy
     182  DebugCommandLedTestToggle
     158  DebugCommandPrepareList
      70  DebugCommandSysTimeToggle
     188  DebugInitialize
     102  DebugLedTestCharacter
      28  DebugLineFeed
     176  DebugPrintNumber
      36  DebugPrintf
      12  DebugRunActiveState
      40  DebugRxCallback
     178  DebugSM_CheckCmd
      52  DebugSM_Error
     290  DebugSM_Idle
      24  DebugSM_ProcessCmd
      64  DebugScanf
       4  Debug_Uart
      64  Debug_au8CommandBuffer
      64  Debug_au8Commands
     128  Debug_au8RxBuffer
      68  Debug_au8StartupMsg
       4  Debug_pfnStateMachine
       4  Debug_pu8CmdBufferNextChar
       4  Debug_pu8RxBufferNextChar
       4  Debug_pu8RxBufferParser
       2  Debug_u16CommandSize
       4  Debug_u32CurrentMessageToken
       1  Debug_u8Command
       1  Debug_u8ErrorCode
     128  G_au8DebugScanfBuffer
       4  G_u32DebugFlags
       1  G_u8DebugScanfCharCount
     116  SystemStatusReport
       4  au8BackspaceSequence
       8  au8CommandHeader
      32  au8CommandOverflow
      24  au8DebugErrorMsg
      20  au8InvalidCommand

 
   353 bytes in section .bss
   220 bytes in section .data
   518 bytes in section .rodata
 1 886 bytes in section .text
 
 1 886 bytes of CODE  memory
   518 bytes of CONST memory
   573 bytes of DATA  memory

Errors: none
Warnings: 1
